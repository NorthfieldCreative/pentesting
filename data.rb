#!/usr/bin/env ruby
#
# Copyright (c) 2007-2015, Enphase Energy. All rights reserved.
# data.rb - Envoy WebApp - Data Access Methods

# =========================================================================== #
# Imports
# =========================================================================== #
require 'include/statusbits.rb'
require 'include/emu_utils'
require 'db_conn'
require 'ehdcc'
require 'i18n'
require 'pebif'
require 'libevent'

require 'report_hosts'
require 'enphase_consts'
require 'sys_warn'

include EhDcc

# =========================================================================== #
# Constants
# =========================================================================== #
# Device Types
PCU  = EID_DEVTYPE_PCU
PCU2 = EID_DEVTYPE_PCU2
EMU  = EID_DEVTYPE_EMU
PMU  = EhDcc::EID_DEVTYPE_PMU unless defined?(PMU)
CMU  = EID_DEVTYPE_CMU
AMU  = EID_DEVTYPE_AMU
ENVIRON = EID_DEVTYPE_ENVIRON
RGM = EID_DEVTYPE_RGM
ZBRPTR = EID_DEVTYPE_ZBRPTR
EIM = EID_DEVTYPE_EIM

#Interval Types
Raw = 0
Binned = 1
Summary = 2
Lifetime = 3

# Observed flags
Discovering = DEV_OBSERVED_FLAG_DISCOVERING

# Admin state
Deleted = ADMIN_STATE_DELETED

# Device events
ModGone = 10000
ZigBeeUSBGone = 0x0001

MaxPcus = 254
RGMBinWidth = 900
PCUBinWidth = 300

EMU_HTTP_PORT = ENV['EMU_HTTP_PORT'] || '28888' unless defined?(EMU_HTTP_PORT)
EMU_BIN_ROLLER_PORT = ENV['EMU_BIN_ROLLER_2_REST_PORT'] || '8082' unless defined?(EMU_BIN_ROLLER_PORT)
EMU_HOST = '127.0.0.1' unless defined?(EMU_HOST)

$emu_show_invisible_events_val = ENV['EMU_EVENTS_SHOW_INVISIBLE']
if !$emu_show_invisible_events_val.nil? &&
   ($emu_show_invisible_events_val =~ (/(true|t|yes|y|1)$/i))
  $emu_show_invisible_events = true
else
  $emu_show_invisible_events = false
end

$emu_in_manu_mode_val = ENV['EMU_MFG_ENABLED']
if !$emu_in_manu_mode_val.nil? &&
   ($emu_in_manu_mode_val =~ (/(true|t|yes|y|1)$/i))
  $emu_in_manu_mode = true
else
  $emu_in_manu_mode = false
end

## If changed see similar logic in top of
## httpd/rhtdocs/event.rb
$emu_min_num_events_val = ENV['EMU_EVENTS_MIN_NUM']
if !$emu_min_num_events_val.nil? &&
   ($emu_min_num_events_val.to_i.class == Fixnum) &&
   ($emu_min_num_events_val.to_i > 500)
  $emu_min_num_events = $emu_min_num_events_val.to_i
else
  $emu_min_num_events = 500
end

# =========================================================================== #
# Database methods
# =========================================================================== #
def open_db
  @db = DbConn.instance
  #@db.quiet = false       # Uncomment for timing
end

# =========================================================================== #
# Hack to avoid joins, nested selects
# Assumes that the set of non-PCU's doesn't change during the script's run
# =========================================================================== #
def cache_pcu_info
  @non_pcu_chan_eids = @db.execute("SELECT ehc.eid FROM eh_channel ehc, eh_device ehd " <<
                             "WHERE device_type!=#{PCU} " <<
                             " AND device_type!=#{PCU2} " <<
                             " AND ((ehc.eid & #{EID_DEV_SAME_MASK}) == " <<
                             "      (ehd.eid & #{EID_DEV_SAME_MASK})) " <<
                             ";").map { |row|
      row['eid']
    }.join(',')

  @joule_cpi_stat ||= @db.get_first_value("SELECT 'stat'||stat_index FROM stat_name " <<
                                      "WHERE ( device_type=#{PCU} " <<
                                      " OR device_type=#{PCU2} ) " <<
                                      " AND integrated=1 ")

  @joule_ie_stat ||= @db.get_first_value("SELECT 'stat'||tgt_stat_index FROM stat_name " <<
                                      "WHERE ( device_type=#{PCU} " <<
                                      " OR device_type=#{PCU2} ) " <<
                                      " AND integrated=1 ")

  @admin_state_deleted ||= @db.get_first_value("SELECT state_id FROM admin_state " <<
                                               " WHERE state_name='deleted';")

  # here we are getting the list of non-monitored PCUs so that we can exclude
  # it in a variety of wc reports @dcc_eids is the full list, @dev_eids is
  # the a sublist of devices, @ctrl_eids is a sublist of controllers,
  # @chan_eids is a sublist of channels these are comma delimited strings
  #that are great for sql queries
  @nm_data ||= get_not_monitored_dcc_eid_lists
  @nm_dcc_eids  ||= @nm_data[0]
  @nm_dev_eids  ||= @nm_data[1]
  @nm_ctrl_eids ||= @nm_data[2]
  @nm_chan_eids ||= @nm_data[3]
end
def cache_pmu_info
  @pmu_ids = @db.execute("SELECT ehc.eid FROM eh_channel ehc, " <<
                                               "eh_device ehd " <<
                             "WHERE device_type==#{PMU} " <<
                             " AND ((ehc.eid & #{EID_DEV_SAME_MASK}) == " <<
                             "      (ehd.eid & #{EID_DEV_SAME_MASK})) " <<
                             ";").map { |row|
      row['eid']
    }.join(',')

  @pmu_whdel_ie_stat ||= @db.get_first_value("SELECT 'stat'||tgt_stat_index FROM " <<
                                      "stat_name WHERE device_type=#{PMU} " <<
                                      "AND stat_name='Wh Delivered';")
  @pmus_present = @db.get_first_value("SELECT * FROM eh_device ehd, " <<
                                        "admin_state ast, equipment eq WHERE " <<
                                        "ehd.device_type=#{PMU} AND " <<
                                        "ast.state_name != 'deleted' AND " <<
                                        "eq.eid == ehd.eid AND " <<
                                        "ast.state_id == eq.admin_state;")
end

def cache_emu_info
  @emu_cond_flags = @db.get_first_value("SELECT eqd.condition_flags " +
                                          "FROM equipment_data eqd, " +
                                          "     eh_device ehd " +
                                          "WHERE ehd.device_type == #{EMU} " +
                                          "AND ehd.eid == eqd.eid;").to_i
end

  #rgm_active - comma seperated list of RGMs in the that are active in network

def cache_rgm_info

  #rgm_chan_ids - comma seperated list of RGM channel ids
  # includes RMA'd devices
  # used to retrieve power data from the database
  @rgm_chan_ids =@db.execute("SELECT ehc.eid " <<
                            " FROM eh_channel ehc, eh_device ehd " <<
                            " WHERE device_type==#{RGM} " <<
                            " AND ((ehc.eid & #{EID_DEV_SAME_MASK}) == " <<
                            "      (ehd.eid & #{EID_DEV_SAME_MASK})) " <<
                            ";").map { |row|
                                       row['eid']
                                     }

  #rgm_ctrl_ids - comma seperated list of RGMs in the database
  # could include RMA'd devices
  # used to determine number of active devices
  # modgone is reported against controllers
  @rgm_ctrl_ids = @db.execute("SELECT ehc.eid " <<
                           " FROM eh_controller ehc, eh_device ehd " <<
                           " WHERE device_type==#{RGM} " <<
                           " AND ((ehc.eid & #{EID_DEV_SAME_MASK}) == " <<
                           "      (ehd.eid & #{EID_DEV_SAME_MASK})) " <<
                           ";").map { |row|
                                      row['eid']
                                    }
  @rgm_cnt = @rgm_ctrl_ids.size

  #rgm_configured - list of RGMs in the that are configured in network
  @rgm_configured = @db.execute("SELECT eid " <<
                "FROM equipment " <<
                "WHERE eid IN  (#{@rgm_ctrl_ids.join(',')}) " <<
                "AND admin_state != #{ADMIN_STATE_DELETED};").map { |row|
                                                               row['eid'].to_i
                                                             }
  @rgm_configured_cnt = @rgm_configured.size

  @rgm_configured_chan = @db.execute("SELECT eid " <<
                "FROM equipment " <<
                "WHERE eid IN  (#{@rgm_chan_ids.join(',')}) " <<
                "AND admin_state != #{ADMIN_STATE_DELETED};").map { |row|
                                                               row['eid'].to_i
                                                             }
  @rgm_configured_chan_cnt = @rgm_configured_chan.size

  q = "SELECT condition_flags, observed_flags, eid " <<
      "FROM equipment_data WHERE eid IN (#{@rgm_ctrl_ids.join(',')});"
  @rgm_ctrl_flags = @db.execute(q).inject({}) do |h,row|
      h[row['eid'].to_i] = row
      h
  end

  q = "SELECT condition_flags, observed_flags, eid " <<
      "FROM equipment_data WHERE eid IN (#{@rgm_chan_ids.join(',')});"
  @rgm_chan_flags = @db.execute(q).inject({}) do |h,row|
      h[row['eid'].to_i] = row
      h
  end

  #rgm_active - comma seperated list of RGMs in the that are active in network
  @rgm_display_status = {}
  a_tmp = []
  @rgm_active_cnt = 0
  @rgm_ctrl_ids.each do |eid|
    if @rgm_configured.include?(eid.to_i)
      chanfl = displayChanConditionFlagsRgm(
          @rgm_chan_flags[Eid.to_chan_eid(eid.to_i)]['condition_flags'].to_i,
          @rgm_chan_flags[Eid.to_chan_eid(eid.to_i)]['observed_flags'].to_i
      )
      ctrlfl = displayCtrlConditionFlagsRgm(
          @rgm_ctrl_flags[eid.to_i]['condition_flags'].to_i,
          @rgm_ctrl_flags[eid.to_i]['observed_flags'].to_i
      )
      if chanfl != "OK" && ctrlfl != "OK"
        @rgm_display_status[eid.to_i] = chanfl +"|"+ ctrlfl
      elsif chanfl != "OK"
        @rgm_display_status[eid.to_i] = chanfl
      elsif ctrlfl != "OK"
        @rgm_display_status[eid.to_i] = ctrlfl
      else
        @rgm_display_status[eid.to_i] = "OK"
        @rgm_active_cnt += 1
        a_tmp << eid
      end
    else
        @rgm_display_status[eid.to_i] = "Deleted"
    end
  end
  @rgm_active = a_tmp.join(',')

  @rgm_whdel_cpi_stat ||= @db.get_first_value("SELECT 'stat'||stat_index " <<
                                          "FROM stat_name " <<
                                          "WHERE device_type=#{RGM} AND stat_name='Wh Delivered';")

  @rgm_whdel_ie_stat ||= @db.get_first_value("SELECT 'stat'||tgt_stat_index " <<
                                          "FROM stat_name " <<
                                          "WHERE device_type=#{RGM} AND stat_name='Wh Delivered';")

  @rgm_watt_cpi_stat ||= @db.get_first_value("SELECT 'stat'||stat_index " <<
                                          "FROM stat_name " <<
                                          "WHERE device_type=#{RGM} AND stat_name='Instantaenous Demand';")

  @rgm_watt_re_stat ||= @db.get_first_value("SELECT 'stat'||tgt_stat_index " <<
                                          "FROM stat_name " <<
                                          "WHERE device_type=#{RGM} AND stat_name='Instantaenous Demand';")

end
# =========================================================================== #
# Date formating methods
# =========================================================================== #
def format_date(dt)
  begin
    I18n.l(Time.at(dt.to_i), :format => :event_datetime)
  rescue
    return "#{dt.to_s}"
  end
end


# Format an integer value to fit in a width-size field.
# Scale the value down if necessary, adjusting the scale and corresponding prefix
# (the prefix width is deducted from the total field width).
# Append the unit to the returned string, whose total length is width+unit.length.
# Do not display a fractional part for a value when int_only is true, unless the
# value needs to be scaled to fit the width.
# lcd - true if formatting for the lcd
def format_with_prefix(width, value, scale, unit, lcd, int_only = false)
  frmStr = ""

  prefixes = {0=>'', 3=> 'k', 6=>'M', 9=>'G', 12=>'T', 15=>'P',
                    18=>'E', 21=>'Z', 24=>'Y'}
  value = value.to_f * (10**scale) # convert to Wh
  scale =0
  precision=0

  # space is allocated on the lcd, so push the value, scale and units together
  # for the local web interface, format with a space after the value
  if lcd
    strFormat = "%s%s%s"
  else
    strFormat = "%s %s%s"
  end

  if(value<=0)
      format_value = format("%5d",value)
      frmStr = format("#{strFormat}",format_value,prefixes[scale],unit)
  else
    while(!(value >0 && value <1000) ) #issue do not need to check for >0 case always true at this point.
      value = value/1000;
      scale = scale+3;
    end
    precision = case value
      when 0...10       then 2
      when 10...100     then 1
      when 100...1000   then 0
    end
    if(scale == 0)
      format_value = format(" %*.*f",width,precision,value)
    else
      format_value = format("%*.*f",width,precision,value)
    end
    frmStr = format("#{strFormat}",format_value,prefixes[scale],unit) #width-precision-prefixes[scale].length
  end

  # now apply the localization to the string
  # get the localized separator and delimiter that we care about
  numberFormat = I18n.t(:'number.format')

  parts = frmStr.to_s.split('.')
  parts[0].gsub!(/(\d)(?=(\d\d\d)+(?!\d))/, "\\1#{numberFormat[:delimiter]}")

  return parts.join(numberFormat[:separator])

end

# =========================================================================== #
# Status formating methods
# =========================================================================== #
def displayCtrlConditionFlagsPcu(cond, obs, sep = "|", okStr = "OK")
  ConditionFlagsCtrlPcu.new(cond, obs).to_s(sep, okStr)
end

def displayChanConditionFlagsPcu(cond, obs, sep = "|", okStr = "OK")
  ConditionFlagsChanPcu.new(cond, obs).to_s(sep, okStr)
end

def displayCtrlConditionFlagsCmu(cond, obs, sep = "|", okStr = "OK")
  ConditionFlagsCtrlCmu.new(cond, obs).to_s(sep, okStr)
end

def displayChanConditionFlagsCmu(cond, obs, sep = "|", okStr = "OK")
  ConditionFlagsChanCmu.new(cond, obs).to_s(sep, okStr)
end

def displayCtrlConditionFlagsPmu(cond, obs, sep = "|", okStr = "OK")
  ConditionFlagsCtrlPmu.new(cond, obs).to_s(sep, okStr)
end

def displayChanConditionFlagsPmu(cond, obs, sep = "|", okStr = "OK")
  ConditionFlagsChanPmu.new(cond, obs).to_s(sep, okStr)
end

def displayCtrlConditionFlagsRgm(cond, obs, sep = "|", okStr = "OK")
  cache_emu_info
  ConditionFlagsCtrlRgm.new(cond, obs, @emu_cond_flags).to_s(sep, okStr)
end

def displayChanConditionFlagsRgm(cond, obs, sep = "|", okStr = "OK")
  ConditionFlagsChanRgm.new(cond, obs).to_s(sep, okStr)
end

def displayCtrlConditionFlagsZbrptr(cond, obs, sep = "|", okStr = "OK")
  ConditionFlagsCtrlZbrptr.new(cond, obs).to_s(sep, okStr)
end

# =========================================================================== #
# Unit Conversion methods
# =========================================================================== #
def j_to_kWh(j)
  (j.to_f)/3600000
end

def j_to_Wh(j)
  (j.to_f)/3600
end

# wh_to_watt - convert from watt-hours to watts
# 1) convert to watt-seconds
# 2) divide by duration
def wh_to_watt(wh, time)
  val = 0.0
  val = (wh.to_f * 3600.0)/time unless time == 0
  val
end

# =========================================================================== #
# Data Access methods
# =========================================================================== #
def get_lifetime_kWh
  cache_pcu_info
  lifetime_j = 0
  # Bug 2435: look in RAW if nothing in LIFETIME #issue looking in binned not raw correction needed
  [ { 'name' => DbConn::LIFETIME_DB_NAME,
      'tbl' => 'integrated_elements',
      'stat' => @joule_ie_stat },
    { 'name' => DbConn::BINNED_DB_NAME,
      'tbl' => 'integrated_elements',
      'stat' => @joule_ie_stat} ].each do |dbinfo|
    @db.attach(dbinfo['name'])
    stmt = "SELECT sum(#{dbinfo['stat']})" <<
           " FROM #{dbinfo['name']}.#{dbinfo['tbl']}" <<
           " WHERE device_id NOT IN (#{@non_pcu_chan_eids})" <<
           " AND device_id NOT IN (#{@nm_chan_eids});"
    lifetime_j = @db.get_first_value(stmt).to_i
    break if lifetime_j > 0
  end
  j_to_kWh(lifetime_j)
end

def get_current_watts
  cache_pcu_info
  devWatts = {}
  now = Time.now.to_i
  threshold = now - 30*Min
  #Update now, to take into account incomplete bins
  now += PCUBinWidth

  # Bug 2435: look in RAW if nothing in BINNED
  # Bug 5357: Look in Main in the interest of being the most up to date;
  # order by increasing interval date so that only the most recent get included
  [ { 'name' => DbConn::BINNED_DB_NAME,
      'tbl' => 'integrated_elements',
      'stat' => @joule_ie_stat },
    { 'name' => DbConn::RAW_DB_NAME,
      'tbl' => 'channel_perf_interval',
      'stat' => @joule_cpi_stat },
    { 'name' => DbConn::MAIN_DB_NAME,
      'tbl' => 'channel_perf_interval',
      'stat' => @joule_cpi_stat  } ].each do |dbinfo|
    if dbinfo['name'] != DbConn::MAIN_DB_NAME
      @db.attach(dbinfo['name'])
    end
    # Bug 1337:
    # - force join order using CROSS JOIN instead of ","
    # - eliminate admin_state join by using cached id for deleted
    # Bug 2476:
    # - Simplify query: no need for deleted check since was no deleted when
    #   energy accumulated. Also no need for order by clause.
    #   Also no need for device reference.
    #
    q = "SELECT cpi.device_id, cpi.#{dbinfo['stat']}, cpi.stat_duration " <<
        "FROM #{dbinfo['name']}.#{dbinfo['tbl']} cpi, " <<
        "     eh_channel ehc " <<
        "WHERE cpi.device_id NOT IN (#{@non_pcu_chan_eids}) " <<
        "AND cpi.device_id NOT IN (#{@nm_chan_eids}) " <<
        "AND cpi.device_id == ehc.eid " <<
        "AND cpi.interval_end_date > #{threshold} " <<
        "AND cpi.interval_end_date <= #{now} "  <<
        "AND cpi.interval_type <> -1 "  <<
        "ORDER BY cpi.interval_end_date;"
    @db.execute(q).each do |row|
      devWatts[row['device_id']] = row[dbinfo['stat']].to_f / row['stat_duration'].to_f
    end

  end

  devWatts.values.inject(0) { |total, w| total + w }
end

def get_rgm_lifetime_kWh
  cache_rgm_info
  lifetime_wh = 0.0
  [ { 'name' => DbConn::LIFETIME_DB_NAME,
      'tbl' => 'integrated_elements',
      'stat' => @rgm_whdel_ie_stat },
    { 'name' => DbConn::RAW_DB_NAME,
      'tbl' => 'channel_perf_interval',
      'stat' => @rgm_whdel_cpi_stat} ].each do |dbinfo|
    @db.attach(dbinfo['name'])
    lifetime_wh = @db.get_first_value("SELECT sum(#{dbinfo['stat']}) FROM " <<
                  "#{dbinfo['name']}.#{dbinfo['tbl']} WHERE " <<
                  "device_id IN (#{@rgm_chan_ids.join(',')});").to_f
    break if lifetime_wh > 0.0
  end
  return( lifetime_wh / 1000 )
end

def get_rgm_lifetime_kWh_ctrl(chan_eid)
  cache_rgm_info
  @db.attach(DbConn::LIFETIME_DB_NAME)
  lifetime_wh = 0.0
  [ { 'name' => DbConn::LIFETIME_DB_NAME,
      'tbl' => 'integrated_elements',
      'stat' => @rgm_whdel_ie_stat },
    { 'name' => DbConn::RAW_DB_NAME,
      'tbl' => 'channel_perf_interval',
      'stat' => @rgm_whdel_cpi_stat} ].each do |dbinfo|
    @db.attach(dbinfo['name'])
    lifetime_wh += @db.get_first_value("SELECT #{dbinfo['stat']} FROM " <<
                   "#{dbinfo['name']}.#{dbinfo['tbl']} " <<
                   "WHERE device_id=#{chan_eid.to_i};").to_f
    break if lifetime_wh > 0.0
  end
  return( lifetime_wh / 1000 )
end

def get_rgm_current_watts
  cache_rgm_info
  watts = 0
  now = Time.now.to_i
  # FIXME - 30 minutes is not right it should be some multiple of polling period
  threshold = now - 30*Min
  #Update now, to take into account incomplete bins
  now += RGMBinWidth
  watts = 0

  # Bug 2435: look in RAW if nothing in BINNED
  # Bug 5357: Look in Main in the interest of being the most up to date;
  # order by increasing interval date so that only the most recent get included
  [ { 'name' => DbConn::BINNED_DB_NAME,
      'tbl' => 'reading_elements',
      'stat' => @rgm_watt_re_stat    },
    { 'name' => DbConn::RAW_DB_NAME,
      'tbl' => 'channel_perf_interval',
      'stat' => @rgm_watt_cpi_stat   },
    { 'name' => DbConn::MAIN_DB_NAME,
      'tbl' => 'channel_perf_interval',
      'stat' => @rgm_watt_cpi_stat   } ].each do |dbinfo|
    if dbinfo['name'] != DbConn::MAIN_DB_NAME
      @db.attach(dbinfo['name'])
    end

    @rgm_configured_chan.each do |eid|
      stmt = "SELECT #{dbinfo['stat']} " <<
             "FROM #{dbinfo['name']}.#{dbinfo['tbl']} " <<
             "WHERE device_id IN (#{eid}) " <<
             "AND interval_end_date > #{threshold} " <<
             "AND interval_end_date <= #{now} "  <<
             "AND interval_type <> -1 "  <<
             "ORDER BY interval_end_date DESC LIMIT 1;"
      watts += @db.get_first_value(stmt).to_i
    end

    break if watts > 0
  end
  watts
end

def get_active_rgm_count
  cache_rgm_info
  @rgm_active_cnt
end

def get_state_of_rgms
  cache_emu_info
  cache_rgm_info
  active = 0

  zigBeeCondition = (@emu_cond_flags.to_i & ZigBeeUSBGone)
  if zigBeeCondition == 0
    active = get_active_rgm_count
  end

  [@rgm_configured_cnt, active]
end

def rgm_present?
    cache_rgm_info
    return( @rgm_active_cnt > 0 )
end

def sum_rgm_binned_wh(secs)
  cache_rgm_info
  now = Time.now.to_i
  start = now - secs
  #Update now, to take into account incomplete bins
  now += RGMBinWidth
  select = "SELECT sum(#{@rgm_whdel_ie_stat}) " <<
           "FROM %s.integrated_elements " <<
            "WHERE device_id IN (#{@rgm_chan_ids.join(',')}) " <<
            "AND interval_end_date <= #{now} " <<
            "AND interval_end_date > #{start};"

  @db.attach(DbConn::BINNED_DB_NAME)
  period_data = @db.get_first_row(format(select, DbConn::BINNED_DB_NAME))
  period_wh = period_data[0].to_i
  DbConn.archive_dbs do |arch|
    # Use timestamp in archive path to determine whether to look in it; the time
    # of archive creation must be >= the interval_end_date of any complete interval
    # in the database.
    next if arch =~ /\/(\d+)\// && $1.to_i < start
    @db.msg "looking in #{arch} for energy since #{start}"
    @db.open_archive(arch) do |dbName|
      period_data = @db.get_first_row(format(select, dbName))
      period_wh += period_data[0].to_i
    end
  end
  period_wh
end

def get_rgm_kWh_today
  # Issue 255: since midnight, not last 24 hours
  # Sufficient to go back to any time in midnight hour, for reasonable latitudes :-)
  wh = sum_rgm_binned_wh(Time.now.hour*Hour)
  return (wh/1000.0)
end

def get_rgm_kWh_past_week
  wh = sum_rgm_binned_wh(Week)
  return (wh/1000.0)
end

def get_rgm_kWh_past_30days
  wh = sum_rgm_binned_wh(30*Day)
  return (wh/1000.0)
end

def get_rgm_display_status
  return @rgm_display_status
end

def get_pmu_total_lifetime_kWh
    cache_pmu_info
    @db.attach(DbConn::LIFETIME_DB_NAME)
    lifetime_wh = @db.get_first_value("SELECT sum(#{@pmu_whdel_ie_stat}) FROM " <<
                  "#{DbConn::LIFETIME_DB_NAME}.integrated_elements WHERE " <<
                  "device_id IN (#{@pmu_ids}) " <<
                  "AND interval_type=#{Lifetime};").to_f
    return( nil ) if( lifetime_wh.nil? )
    return( lifetime_wh / 1000 )
end

def get_pmu_lifetime_kWh(chan_eid)
    cache_pmu_info
    @db.attach(DbConn::LIFETIME_DB_NAME)
    lifetime_wh = 0.0
    lifetime_wh += @db.get_first_value("SELECT #{@pmu_whdel_ie_stat} FROM " <<
                   "#{DbConn::LIFETIME_DB_NAME}.integrated_elements " <<
                   "WHERE device_id=#{chan_eid.to_i};").to_f
    return( lifetime_wh / 1000 )
end

def pmu_present?
    cache_pmu_info
    return( @pmus_present != nil )
end

def sum_binned_energy(secs)
  cache_pcu_info
  now = Time.now.to_i
  start = now - secs
  #Update now, to take into account incomplete bins
  now += PCUBinWidth
  select = "SELECT sum(#{@joule_ie_stat}) FROM %s.integrated_elements " <<
            "WHERE device_id NOT IN (#{@non_pcu_chan_eids}) " <<
            "AND device_id NOT IN (#{@nm_chan_eids}) " <<
            "AND interval_type = #{Binned} " <<
            "AND interval_end_date <= #{now} " <<
            "AND interval_end_date > #{start};"

  @db.attach(DbConn::BINNED_DB_NAME)
  period_j = @db.get_first_value(format(select, DbConn::BINNED_DB_NAME)).to_i
  DbConn.archive_dbs do |arch|
    # Use timestamp in archive path to determine whether to look in it; the time
    # of archive creation must be >= the interval_end_date of any complete interval
    # in the database.
    next if arch =~ /\/(\d+)\// && $1.to_i < start
    @db.msg "looking in #{arch} for energy since #{start}"
    @db.open_archive(arch) do |dbName|
      period_j += @db.get_first_value(format(select, dbName)).to_i
    end
  end
  j_to_kWh(period_j)
end

def get_energy_today
  # Issue 255: since midnight, not last 24 hours
  # Sufficient to go back to any time in midnight hour, for reasonable latitudes :-)
  sum_binned_energy(Time.now.hour*Hour)
end

def get_energy_past_week
  sum_binned_energy(Week)
end

def get_energy_past_30days
  sum_binned_energy(30*Day)
end

# Get the latest "limit" event records that are visible, etc.  Note that this
# does not include seiral number info but does include eid.
def all_events(limit=$emu_min_num_events)

  # TODO - need to implement the environment variable in the
  # implementation layer under GetHistory
  if $emu_show_invisible_events
    visibility_cond = ""
  else
    visibility_cond = " AND ec.event_visible == 1"
  end

  gh = GetHistory.new(limit)
  success, hist = gh.get()
  if(!success)
    web_comm_msg "Could not get event history"
    return Array.new()
  end

  return hist

end

# Get all of the serial numbers with associated device EID.  This is useful
# when wanting to associate event records with serial numbers.
def all_serials

  sql = "SELECT eid, serial_num FROM eh_device;"
  sn = {}
  @db.execute(sql).each { |row| sn[row['eid'].to_i] = row['serial_num'] }

  return sn
end

def web_comm_msg text
  old_stdout = $stdout
  $stdout = File.open("/var/log/emu/task_queue.log", "a")
  # write to log file
  time = Time.now()
  puts "[" << time.strftime("%Y/%m/%d %H:%M:%S") << (time.to_f - time.to_i).to_s[1,7] << "] | [web_comm] | " << text
  $stdout.flush
  # reset stdout
  $stdout = old_stdout
end

def get_min_report_time
  rpt_types = "(#{EMU_DEVATTR_PING_INTVL}, " +
               "#{EMU_DEVATTR_PERF_INTVL}, " +
               "#{EMU_DEVATTR_EVT_INTVL}, " +
               "#{EMU_DEVATTR_READING_INTVL})"
  min_rpt_time = 0
  @ping_rpt_time = 300
  @perf_rpt_time = 300
  @event_rpt_time = 300
  @read_rpt_time = 300

  begin
    sql = "SELECT device_attr_idx, attr " +
          "FROM device_attr "  +
          "WHERE device_id = #{EMU_DEV_EID_VAL} " +
          "AND device_attr_idx IN #{rpt_types};"
    @db.execute(sql).each do |row|
      type = row['device_attr_idx'].to_i
      val = row['attr'].to_i
      case type
      when EMU_DEVATTR_PING_INTVL
        @ping_rpt_time = val
      when EMU_DEVATTR_PERF_INTVL
        @perf_rpt_time = val
      when EMU_DEVATTR_EVT_INTVL
        @event_rpt_time = val
      when EMU_DEVATTR_READING_INTVL
        @read_rpt_time = val
      end
    end

    if ((@perf_rpt_time != 0) ||
        (@event_rpt_time != 0) ||
        (@read_rpt_time != 0))
      min_rpt_time = [300, @perf_rpt_time].max
      min_rpt_time = [min_rpt_time, @event_rpt_time].min unless (@event_rpt_time == 0)
      min_rpt_time = [min_rpt_time, @read_rpt_time].min unless (@read_rpt_time == 0)
    end

  rescue StandardError => exc
    web_comm_msg "Exception caught\n#{exc.to_s}\n#{exc.backtrace}"
  rescue SQLite3::Exception => exc
    web_comm_msg "SQL Exception caught\n#{exc.to_s}\n#{exc.backtrace}"
  ensure
    return min_rpt_time
  end
end

def get_last_report
  latest_rpt = 0
  @wcs = []

  begin
    @db.attach(DbConn::BINNED_DB_NAME)

    sql = "SELECT * FROM #{DbConn::BINNED_DB_NAME}.web_comm_status;"
    @db.execute(sql).each do |row|
      type = row['type'].to_i
      @wcs[type] = row
    end

    for i in WC_STATUS_FAILED..WC_STATUS_PING_RPT_FAILED
      if @wcs[i] == nil
        @wcs[i] = []
        @wcs[i] = {'type' => i.to_s,
                   'counter' => "0",
                   'timestamp' => "0",
                   'status' => "0",
                   'data_count' => "0"}
      end
    end

  rescue StandardError => exc
    web_comm_msg "Exception caught\n#{exc.to_s}\n#{exc.backtrace}"
  rescue SQLite3::Exception => exc
    web_comm_msg "SQL Exception caught\n#{exc.to_s}\n#{exc.backtrace}"
  end

  last_ping ||= @wcs[WC_STATUS_PING_RPT]['timestamp'].to_i
  last_perf ||= @wcs[WC_STATUS_PERF_CMPLT]['timestamp'].to_i

  return [last_ping, last_perf].max
end


def get_web_comm_status
  status = false
  now = Time.now.to_i
  min_rpt_time = get_min_report_time
  latest_rpt = get_last_report
  $time_last_good_rpt = 0

  if latest_rpt == 0
    web_comm_msg "get_web_comm_status: latest report is zero, status is false"
    return status
  end

  begin
    tq_start ||= @wcs[WC_STATUS_TASK_QUEUE]['timestamp'].to_i
    last_ping ||= @wcs[WC_STATUS_PING_RPT]['timestamp'].to_i
    last_perf ||= @wcs[WC_STATUS_PERF_CMPLT]['timestamp'].to_i
    last_ping_cnt ||= @wcs[WC_STATUS_PING_RPT]['counter'].to_i
    last_perf_cnt ||= @wcs[WC_STATUS_PERF_CMPLT]['counter'].to_i

    delta_start = 0
    good_rpt_window = 0
    good_ping_window = 0

    delta_start = now - tq_start if tq_start < now
    delta_last_good_ping = now - last_ping
    delta_last_good_perf = now - last_perf

    if (delta_start >= (8 * Hour))
      good_rpt_window = (min_rpt_time * 3)
      good_ping_window = (@ping_rpt_time * 3)

      if (delta_last_good_perf <= good_rpt_window)
        status = true
        $time_last_good_rpt = last_perf
      elsif (last_perf_cnt > 0) || (min_rpt_time == 0)
        if (delta_last_good_ping <= good_ping_window)
          status = true
          $time_last_good_rpt = last_ping
        end
      end
    elsif (delta_start >= min_rpt_time)
      # need a little tolerance on the window since reports can be slow
      # due to system busy
      good_rpt_window = (min_rpt_time + (min_rpt_time / 4))
      good_ping_window = (@ping_rpt_time + (@ping_rpt_time / 4))

      if (delta_last_good_perf <= good_rpt_window)
        status = true
        $time_last_good_rpt = last_perf
      elsif (last_perf_cnt > 0) || (min_rpt_time == 0)
        if (delta_last_good_ping <= good_ping_window)
          status = true
          $time_last_good_rpt = last_ping
        end
      end
    elsif (delta_start > 0)
      if (delta_last_good_perf <= delta_start)
        status = true
        $time_last_good_rpt = last_perf
      elsif (delta_last_good_ping <= delta_start)
        status = true
        $time_last_good_rpt = last_ping
      end
    else
      status = false
    end

    web_comm_msg "status:#{status} tq_delta:#{delta_start},  min_rpt:#{min_rpt_time} " +
                 "[rpt last_good:#{(last_perf_cnt > 0)}, " +
                 "win:#{good_rpt_window}, delta:#{delta_last_good_perf}] " +
                 "[ping last_good:#{(last_ping_cnt > 0)}, " +
                 "win:#{good_ping_window}, delta:#{delta_last_good_ping}]"

  rescue StandardError => exc
    @db.msg "Exception caught\n#{exc.to_s}\n#{exc.backtrace}", true
  ensure
    return status
  end
end #get_web_comm_status



def get_last_web_comm
  now = Time.now.to_i
  webcomm_status = get_web_comm_status
  last_perf ||= @wcs[WC_STATUS_PERF_CMPLT]['timestamp'].to_i
  last_ping ||= @wcs[WC_STATUS_PING_RPT]['timestamp'].to_i
  tq_start ||= @wcs[WC_STATUS_TASK_QUEUE]['timestamp'].to_i
  failed_rpt ||= @wcs[WC_STATUS_FAILED]['timestamp'].to_i

  ever_connected = (last_perf != 0)

  # if last complete perf report is 0, we have never received a perf response
  if(!ever_connected)
    return "<div class=bad>#{I18n.t('scripts.data.never_connected')}</div>", ever_connected, 0
  end

  last_report_good = ($time_last_good_rpt > failed_rpt)
  secsSince = 0
  secsSince = now - $time_last_good_rpt if now > $time_last_good_rpt
  web_comm_msg "get_last_web_comm: status:#{webcomm_status} last_report_good:#{last_report_good}, " +
               "time_last_good_rpt:#{$time_last_good_rpt} secsSince:#{secsSince}  last_perf:#{last_perf}"
  if webcomm_status
    minSince = (secsSince/Min).floor
    last_web_comm_text = "<div class=#{((last_report_good)? 'good': 'bad')}>" << " #{I18n.t('datetime.distance_in_words.x_minutes', :count => minSince)}</div>"
  else
    last_web_comm_text = "<div class=bad>#{I18n.t('scripts.data.last_communication_date')} #{I18n.l(Time.at(last_perf), :format => :event_datetime)}</div>"
  end

  return last_web_comm_text, ever_connected, last_perf
end

def get_channel_count
  channels = @db.execute("SELECT eq.eid " +
                         "FROM eh_channel ehc, equipment eq " +
                         "WHERE eq.eid == ehc.eid " +
                         "  AND eq.admin_state <> #{ADMIN_STATE_DELETED};")
  return channels.inject(0) do |count, row|
    devtype = Eid.new(row['eid'].to_i).devtyp
    (devtype == PCU || devtype == PCU2) ? count + 1 : count
  end
end

# Returns a level specific lists of eids for PCU/PCU2 where the
# device level observed notMonitored bit was set
def get_not_monitored_dcc_eid_lists
  stmt = "SELECT pcu.eid FROM equipment_data pcu, equipment_data ehd " +
         "WHERE ((((pcu.eid & #{EID_DEVTYP_MASK}) == #{EID_PCU_DEVTYPE_MASK}) " +
         "        OR ((pcu.eid & #{EID_DEVTYP_MASK}) == #{EID_PCU2_DEVTYPE_MASK})) " +
         "       AND (((ehd.eid & #{EID_PCU_DEV_MASK}) == #{EID_PCU_DEV_MASK})" +
         "            AND ((ehd.observed_flags & #{DEV_OBSERVED_FLAG_NOTMONITORED}) <> 0)) " +
         "        AND ((ehd.eid & #{EID_DEV_MASK}) == (pcu.eid & #{EID_DEV_MASK})));"

  #@db.msg "get_not_monitored_chan_eid_list stmt:#{stmt}", true

  lv_nm_dcc_eids = ""
  lv_nm_dev_eids = ""
  lv_nm_ctrl_eids = ""
  lv_nm_chan_eids = ""

  @db.execute(stmt).each do |row|
   lv_nm_dcc_eids += ", " unless lv_nm_dcc_eids == ""
   lv_nm_dcc_eids += row['eid']

   if ((row['eid'].to_i & EID_LEVEL_MASK) == EID_PCU_DEV_LEVEL_MASK)
     lv_nm_dev_eids += ", " unless lv_nm_dev_eids == ""
     lv_nm_dev_eids += row['eid']
   end

   if ((row['eid'].to_i & EID_LEVEL_MASK) == EID_PCU_CTRL_LEVEL_MASK)
     lv_nm_ctrl_eids += ", " unless lv_nm_ctrl_eids == ""
     lv_nm_ctrl_eids += row['eid']
   end

   if ((row['eid'].to_i & EID_LEVEL_MASK) == EID_PCU_CHAN_LEVEL_MASK)
     lv_nm_chan_eids += ", " unless lv_nm_chan_eids == ""
     lv_nm_chan_eids += row['eid']
   end
  end
  #@db.msg "data.rb ** get_not_monitored_dcc_eid_lists dcc_eids :#{lv_nm_dcc_eids}", true
  #@db.msg "data.rb ** get_not_monitored_dcc_eid_lists dev_eids :#{lv_nm_dev_eids}", true
  #@db.msg "data.rb ** get_not_monitored_dcc_eid_lists ctrl_eids:#{lv_nm_ctrl_eids}", true
  #@db.msg "data.rb ** get_not_monitored_dcc_eid_lists chan_eids:#{lv_nm_chan_eids}", true
  return [lv_nm_dcc_eids, lv_nm_dev_eids, lv_nm_ctrl_eids, lv_nm_chan_eids]
end


# Get counts of devices that are active (not deleted), grouped by device tyoe.
# Uses the REST interface rather than SQL.
def get_dev_counts(*dev_types)
  dev_types = (1..EID_LAST_DEVTYPE) if dev_types.empty?
  dev_types = dev_types.to_set

  counts = [0] * (EID_LAST_DEVTYPE + 1)

  data = @pg_parms.pebif.peb_get("#{EnvoyPage.peb_url_prefix}/prov", true)
  # data = JSON.parse(data)

  data.has_key?('dev_types') and data['dev_types'].each do |devs|
    next if not dev_types.member? devs['dev_type']

    devs.has_key?('part_nums') and devs['part_nums'].each do |parts|
      next if not (0..NUM_EH_FOR_DEVS).include? parts['num_serial_nums']

      counts[devs['dev_type']] += parts['num_serial_nums']
    end
  end

  return counts ## [#PCUs, #PCU2s, ..., #ACBs]
end

# Get count of PCUs that are active (not deleted).
def get_pcu_count(counts = nil)
  counts = get_dev_counts()  if counts == nil

  # count each Dualle as 2 devices
  return counts[EID_DEVTYPE_PCU] + 2 * counts[EID_DEVTYPE_PCU2]
end

# Get ACB charging/idle/discharging status indicator
def get_acb_charging_status(n, power) ## ACB count, produced - consumed (in mW, averaged over reporting interval)
  return 'idle'        if n == 0
  return 'discharging' if power >=  1000 * n
  return 'charging'    if power <= -13000 * n
  return 'idle'        ## assume aggregate power in deadband range is ACB keep-alive power
end

def get_production_data(get_from_rgm = nil)
  production_data = {}
  production_data['now_W'] = 0.0
  production_data['today_KWh'] = 0.0
  production_data['week_KWh'] = 0.0
  production_data['life_KWh'] = 0.0
  production_data['from_rgm'] = false

  if $emu_in_manu_mode
    return  production_data
  end

  #@db.msg "get_from_rgm:#{get_from_rgm},", true
  #@db.msg "EMU_HOST:#{EMU_HOST},", true
  #@db.msg "EMU_BIN_ROLLER_PORT:#{EMU_BIN_ROLLER_PORT},", true
  url = "http://#{EMU_HOST}:#{EMU_BIN_ROLLER_PORT}/ivp/bin/production"
  pebif = Enphase::PebIf.new(false, false)
  peb_data = pebif.peb_get(url)
  peb_hash = JSON.parse(peb_data)
  #@db.msg "raw production data:#{peb_hash.inspect},", true

  if peb_hash['there_is_an_active_rgm'] == nil
    @db.msg "Error getting production data", true
  else
    if (get_from_rgm == nil)
      source_rgm = peb_hash['there_is_an_active_rgm']
    else
      source_rgm = get_from_rgm
    end

    if source_rgm
      production_data['now_W'] = peb_hash['watts_now_rgm'] * 1.0
      production_data['today_KWh'] = peb_hash['watt_hours_today_rgm'] / 1000.0
      production_data['week_KWh'] = peb_hash['rgm_watt_hours_seven_days'] / 1000.0
      production_data['life_KWh'] = peb_hash['watt_hours_lifetime_rgm'] / 1000.0
      production_data['from_rgm'] = true
    else
      production_data['now_W'] = peb_hash['watts_now_pcu'] * 1.0
      production_data['today_KWh'] = j_to_kWh(peb_hash['joules_today_pcu'])
      production_data['week_KWh'] = j_to_kWh(peb_hash['pcu_joules_seven_days'])
      production_data['life_KWh'] = j_to_kWh(peb_hash['joules_lifetime_pcu'])
      production_data['from_rgm'] = false
    end
  end

  #@db.msg "production data:#{production_data.inspect},", true
  return production_data
end

def get_active_channel_count
  cache_pcu_info
  count = 0
  lastRptOk = Time.now.to_i - 2*Day
  ctrls = {}
  @db.execute("SELECT ehc.eid, eqd.condition_flags, eqd.observed_flags " +
              "FROM eh_controller ehc, equipment_data eqd " +
              "WHERE eqd.eid = ehc.eid;").each do |row|
      ctrls[row['eid'].to_i] = { 'condition_flags' => row['condition_flags'],
                                 'observed_flags' => row['observed_flags'] }
  end
  chans = []
  @db.execute("SELECT ehc.eid, eqd.condition_flags, eqd.observed_flags, " +
              "       eqd.last_rpt_date, eq.admin_state " +
              "FROM eh_channel ehc, equipment eq, equipment_data eqd " +
              "WHERE ehc.eid NOT IN (#{@non_pcu_chan_eids}) " +
              "AND eq.eid = ehc.eid " +
              "AND eqd.eid = ehc.eid;").each do |row|
      next if row['admin_state'].to_i == ADMIN_STATE_DELETED
      ctrlEid = Eid.new(row['eid'].to_i).to_ctrl_eid
      row['ctrl_eid'] = ctrlEid.to_i
      row['ctrl_condition_flags'] = ctrls[ctrlEid.to_i]['condition_flags']
      row['ctrl_observed_flags'] = ctrls[ctrlEid.to_i]['observed_flags']
      chans << row
  end

  return chans.inject(0) do |count, chan|
    chanStatus = displayChanConditionFlagsPcu(chan['condition_flags'],
                                              chan['observed_flags'])
    controlStatus = displayCtrlConditionFlagsPcu(chan['ctrl_condition_flags'],
                                                 chan['ctrl_observed_flags'])
    if ((chan['last_rpt_date'].to_i >= lastRptOk) &&
        (controlStatus == "OK" || controlStatus == "envoy.cond_flags.pcu_ctrl.altvfsettings") &&
        (chanStatus == "OK"))
      count += 1
    end
    count
  end
end

def get_channel_comm_status
  ctrls = @db.execute("SELECT ehc.eid, eqd.last_rpt_date " <<
                      "FROM eh_controller ehc, equipment_data eqd " <<
                      "WHERE eqd.eid == ehc.eid " <<
                      "ORDER BY last_rpt_date DESC LIMIT 100;")

  lastReportPcu = ctrls.find do |ctrl|
    eid = Eid.new(ctrl['eid'].to_i)
    eid.devtyp == PCU || eid.devtyp == PCU2
  end

  lastReportDate = (lastReportPcu) ? lastReportPcu['last_rpt_date'].to_i : 0
  (Time.now.to_i - lastReportDate <= 10*Min)
end

def get_registration_message
  return_string = ""
  @db.attach(DbConn::BINNED_DB_NAME)
  @db.execute("SELECT status, timestamp FROM web_comm_status" +
              " WHERE status IN (1,2)" +
              " ORDER BY timestamp desc LIMIT 1;").each do |status_record|
    if status_record['status'].to_i == 2 and (Time.now.to_i - status_record['timestamp'].to_i) <= (60*Min)
      report_hosts = Enphase::Emu::ReportHosts.new
      return_string = <<EOF
<div class=bad>
#{I18n.t('scripts.data.registration_message_line1')}
<a href=\"http://#{report_hosts.get_enlighten_host(@db)}/register_emu?serial_num=#{get_emu_serial_num}&amp;locale=#{I18n.locale}\">
#{I18n.t('scripts.data.registration_message_linktext')}</a> #{I18n.t('scripts.data.registration_message_line2')}
</div>
EOF
    end
  end
  return_string
end

def get_system_warning_messages(sw)
  warn_msgs = "<div class=\"bad\">"
  sw.all do |warn|
    warn.strip
    next unless warn.length > 0
    warn_msgs += "<br>"
    warn_msgs += "#{I18n.t('lwui.home.warnings.legend')} : #{I18n.t(warn)}"
    warn_msgs += "<br>"
  end
  warn_msgs += "</div>"
  return warn_msgs
end # get_system_warning_messages

def get_emu_serial_num
  ENV['EMU_SERIAL_NUMBER']
end

def get_emu_sw_part_num
  ENV['EMU_PART_NUMBER']
end

def get_emu_sw_version
  ENV['EMU_VERSION']
end

def get_emu_sw_txn_num
  ENV['EMU_TXN_NUM']
end

# Get the raw appTxnYMD value from '/etc/app_info.json'
#
def get_app_txn_ymd()
  emuInfo = JSON.parse(IO.read("/etc/app_info.json"))
  appTxnYMD = "unknown"

  if (emuInfo.has_key?("app"))
    app = emuInfo['app']

    if (app.has_key?("build_info"))
      buildInfo = app['build_info']

      if (buildInfo.has_key?("appTxnYMD"))
        appTxnYMD =  buildInfo['appTxnYMD']

      end
    end
  end

  return appTxnYMD

end #END AppTxnYMD


# Since the language selection could change between calls to this
# method, the data needs to be re-read each time.
def get_emu_sw_txn_date
  emuInfo = JSON.parse(IO.read("/etc/app_info.json"))
  buildDate = "unknown"
  if emuInfo.has_key?("app")
    app = emuInfo["app"]
    if app.has_key?("build_info")
      buildInfo = app["build_info"]
      tmpDate = ""
      if buildInfo.has_key?("dayOfWeek")
        dayOfWeek = buildInfo["dayOfWeek"].to_i
        tmpDate += "#{I18n.t('date.abbr_day_names')[dayOfWeek]} "
      end

      if buildInfo.has_key?("monthOfYear")
        monthOfYear = buildInfo["monthOfYear"].to_i
        tmpDate += "#{I18n.t('date.abbr_month_names')[monthOfYear]} "
      end

      if buildInfo.has_key?("dayOfMonth")
        tmpDate += "#{buildInfo["dayOfMonth"]}, "
      end

      if buildInfo.has_key?("year")
        tmpDate += "#{buildInfo["year"]} "
      end

      if buildInfo.has_key?("hour")
        tmpDate += "#{buildInfo["hour"]}:"
      end

      if buildInfo.has_key?("minute")
        tmpDate += "#{buildInfo["minute"]} "
      end

      if buildInfo.has_key?("ampm")
        ampm = buildInfo["ampm"]
        tmpDate += (ampm == "AM") ?
                   "#{I18n.t('time.am')} ": "#{I18n.t('time.pm')} "
      end

      if buildInfo.has_key?("tz")
        tmpDate += "#{buildInfo["tz"]}"
      end

      buildDate = tmpDate
    end
  end
  buildDate
end


def get_emu_sw_txn_epoch
  emuInfo = JSON.parse(IO.read("/etc/app_info.json"))
  buildEpoch = 0
  if emuInfo.has_key?("app")
    app = emuInfo["app"]
    if app.has_key?("build_info")
      buildInfo = app["build_info"]
      if buildInfo.has_key?("appTxnEpoch")
        buildEpoch = buildInfo["appTxnEpoch"].to_i
      end
    end
  end
  buildEpoch
end

# Since the language selection could change between calls to this
# method, the data needs to be re-read each time.
def get_emu_sw_build_year
   emuInfo = JSON.parse(IO.read("/etc/app_info.json"))
   buildYear = "2013"
   if emuInfo.has_key?("app")
      app = emuInfo["app"]
      if app.has_key?("build_info")
        buildInfo = app["build_info"]
        if buildInfo.has_key?("year")
          buildYear = buildInfo["year"]
        end
      end
  end
  buildYear
end

def get_db_size
  # sum of archives + binned should be less then MAX_ARCHIVE_SIZE
  max_size = DbConn::MAX_ARCHIVE_SIZE
  size = DbConn.all_dbs.inject(0) { |sum, db| sum + File.size(db) }
  if ((size >> 20) > 1)
    size_str = "#{((size >> 19) + 1) >> 1} MB"
  else
    size_str = "#{((size >>  9) + 1) >> 1} kB"
  end
  percentage_str = "#{(100*size / max_size).round}"

  return size_str, percentage_str

end

# Is there unexported data within a month of deletion?
def show_db_warning?
  warning = false

  # Get list of unexported archived files.
  unexported_list = DbConn.archive_file_data :unexported
  # The first file is ignored since it could be in the process of being exported.
  unexported_count = unexported_list.size

  # Three unexported files are needed to determine if a warning should
  # be issued. The next-oldest and the newest imply a rate (bytes/sec)
  if (unexported_count >= 3)
    unexported_size = unexported_list.inject(0) { | usage, elt | usage + elt['size'] }
    unexported_size -= unexported_list.first['size']
    secs_between_archives = (unexported_list[-1]['date'] - unexported_list[0]['date'])

    if (secs_between_archives > 0)
      #   usage now       +  time span * inferred rate
      if (unexported_size + (30*Day * unexported_size)/secs_between_archives) > DbConn::MAX_ARCHIVE_SIZE
        warning = true
      end
    end
  end

  warning
end

# =========================================================================== #
# Stub methods for Envoy details
# =========================================================================== #
def get_emu_birth_date
  bd = @db.get_first_value("select created_date " +
                           "from eh_device, equipment " +
                           "where device_type == 4;")

  "<div class=good>#{I18n.l(Time.at(bd.to_i), :format => :event_datetime)}</div>"
end

def get_timezone
  tz = (f = File.open("/etc/timezone")).readline.chomp rescue "<div class=bad>Unknown</div>"
  f.close unless f.nil?
  tz
end

def get_emu_plc_asic_partnum
    @db.get_first_value(
            "SELECT attr " <<
            "FROM device_attr da, device_attr_idx dai, " <<
                 "device_type dt, eh_device ehd " <<
            "WHERE ((dt.device_name == 'Envoy') AND " <<
                   "(dai.device_attr_name == 'Main ASIC') AND " <<
                   "(ehd.device_type == dai.device_type) AND " <<
                   "(dai.device_attr_idx == da.device_attr_idx) AND " <<
                   "(ehd.eid == da.device_id));")
end

def get_emu_default_locale
  begin
    locale = (f = File.open("/var/opt/cfg/default_locale")).readline.split
    f.close unless f.nil?
    locale
  rescue
    locale = ["en", "en.yml", "English"]
  end

=begin
    @db.get_first_value(
            "SELECT attr " <<
            "FROM device_attr da, device_attr_idx dai, " <<
                  "device_type dt, eh_device ehd " <<
            "WHERE ((dt.device_name == 'Envoy') AND " <<
                    "(dai.device_attr_name == 'Default Locale') AND " <<
                    "(ehd.device_type == dai.device_type) AND " <<
                    "(dai.device_attr_idx == da.device_attr_idx) AND " <<
                    "(ehd.eid == da.device_id));")
=end

end
